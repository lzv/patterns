Шаблон компоновщик предназначен для случаев, когда имеются объекты, некоторые из которых могут быть частью других объектов, которые в свою очередь могут быть частью вышестоящих объектов. Однако, есть и "листья", которые не могут содержать объекты, а могут только сами содержаться где-либо. При этом со всеми объектами необходимо обращаться единообразно, то есть они все должны иметь один и тот же интерфейс. 
Пример: организация текста в текстовом редакторе. Строка содержит буквы, абзац содержит строки, колонка содержит абзацы, страница содержит колонки. Здесь имеется строгая иерархия, когда сразу понятно, что может чему принадлежать. Но в другом примере может быть по другому, то есть как объект1 может принадлежать объекту2, так и наоборот. 
Проверку, может ли конкретный объект содержать данный объект, приходится проводить во времени выполнения. Например, очевидно, что строка не может содержать страницу, но без проверок такое возможно. 

Есть два варианта реализации в виду различия листьев и остальных объектов. Можно сразу в абстрактном классе-интерфейсе реализовать методы для работы с дочерними объектами, но тогда необходимо отслеживать работу с листьями. Например, ввести статическую переменную класса - уровень иерархии, переопределяемую при наследовании, и проверять при добавлении, что уровень дочернего объекта меньше текущего. Либо можно реализовать эти методы для листьев, как ничего не делающие, и сделать специальный родительский класс для составных объектов, в которых и реализовать полностью эти методы. 

Подробное описание паттерна в книге "Приемы объектно-ориентированного программирования. Паттерны проектирования", со страницы 162. 


