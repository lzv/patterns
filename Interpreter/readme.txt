Пусть часто возникает некоторая задача с различными вариациями. Тогда можно создать язык, на котором одним предложением описать конкретное проявление этой задачи. После этого создается интерпретатор, который решает задачу для каждго контекста. 

Пример: проверка, соответствует ли строка регулярному выражению. Создадим язык (грамматику) регулярных выражений:

expression   ::= literal | alternation | sequence | repetition | '('expression')' 
alternation  ::= expression '|' expression 
sequence     ::= expression '&' expression 
repetition   ::= expression '*' 
literal      ::= 'a' | 'b' | 'c' | ... { 'a' | 'b' | 'c' | ... }* 

Для каждой строки создается свой класс, символы справа - члены класса. Кроме первого класса expression, который будет абстрактным и предоставлять интерфейс. 
После этого для конкретного регулярного выражения строится абстрактное синтаксическое дерево, в узлах которого находятся экземпляры этих классов. В интерфейсе будет определена операция Check, которой будет передаваться контекст - проверяемая строка и текущее место проверки. 
Внимание: паттерн не включает в себя процес распознавания (парсинга) регулярного выражения и построения дерева объектов. Считается, что это дерево уже построено. Процесс интерпретации состоит в преобразовании проверяемой строки в значение типа bool - true, если соответствует регулярному выражению, и false иначе. 

Другой пример - построить дерево для конкретного арифметического выражения с переменными. Контекст - значения переменных. Процесс интерпретации будет состоять в вычислении значения выражения для разных контекстов - разных значений переменных. 

Паттерн следует применять при простой грамматике, для сложных случаев лучше использовать генераторы синтаксических анализаторов. Если новые операции интерпретации создаются часто, можно использовать паттерн Посетитель. При большом количестве терминальных объектов можно использовать паттерн Приспособленец (Flyweight).
